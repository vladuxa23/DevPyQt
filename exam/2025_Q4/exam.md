# Для зачетного задания необходимо:

## 1. Сдать все домашние задания (3 штуки) в виде отдельного репозитория в формате:

* название_репозитория
    * hw_1
    * hw_2
    * hw_3

> Примечание:

    hw_1 - работа с Ui 
    hw_2 - работа с сигналами
    hw_3 - работа с потоками

## 2. Выполнить на выбор одну из задач представленных ниже:

---

### «Сканер папки»

**Задача:** разработать приложение, которое сканирует выбранную папку, считает суммарный размер файлов и отображает 
результат, не блокируя интерфейс.

#### Функциональные требования

1. Пользователь выбирает папку через диалог выбора каталога.
2. Приложение в фоновом потоке:
   * обходит все файлы в выбранной папке (рекурсивно);
   * считает общий размер файлов;
   * ведёт подсчёт количества файлов.
3. В процессе сканирования отображается прогресс (количество обработанных файлов).
4. По завершении:
   * отображаются общие результаты (кол-во файлов, общий размер);
   * выводится лог последней операции (время начала, время завершения, путь к папке).

#### Требования к GUI и виджетам

* Главное окно `QMainWindow` или `QWidget`.
* Обязательные виджеты:

  * `QLineEdit` (отображение выбранного пути),
  * `QPushButton` (выбор папки, старт сканирования),
  * `QProgressBar` (прогресс по количеству файлов),
  * `QTextEdit` или `QPlainTextEdit` (лог событий),
  * `QLabel` (вывод статистики).
* Компоновка через `QVBoxLayout`/`QHBoxLayout` или аналогичные.

#### Сигналы и слоты

* Использовать стандартные сигналы Qt (например, `clicked`, `textChanged`).
* Определить хотя бы один пользовательский сигнал в классе worker, н-р:
  * `progress_changed(int current, int total)`
  * `scan_finished(int file_count, int total_size_bytes)`
  * `error_occurred(str message)`
* Реализовать минимум 2 собственных слота в классе основного окна (обновление прогресса, обработка завершения).

#### Потоки

* Использовать `QThread`:
  * Worker выполняет обход файлов.
  * Рабочий поток не должен обращаться напрямую к виджетам; обновление GUI — через сигналы.
* Обязательная обработка:
  * корректное завершение потока при закрытии приложения;
  * защита от повторного запуска сканирования, пока предыдущий процесс не завершён.

---

### «Менеджер задач (ToDo) с автосохранением»

**Задача:** разработать приложение для управления списком задач с фоновым автосохранением в файл.

#### Функциональные требования

1. Пользователь может:
   * добавлять задачи (заголовок + описание + приоритет),
   * отмечать задачи как выполненные,
   * удалять задачи.
2. Список задач отображается в `QListWidget` или `QTableWidget` с визуальным выделением выполненных.
3. Приложение автоматически сохраняет состояние задач в JSON-файл:
   * вручную по кнопке «Сохранить»;
   * автоматически в фоновом потоке (например, каждые N секунд или при изменении).
4. При запуске приложения список задач загружается из файла (если он есть).

#### Требования к GUI и виджетам

* Виджеты:
  * `QLineEdit` (заголовок),
  * `QTextEdit`/`QPlainTextEdit` (описание),
  * `QComboBox` или `QSpinBox` (приоритет),
  * `QPushButton` (добавить, удалить, сохранить),
  * `QCheckBox` (фильтр «показывать только невыполненные»),
  * `QListWidget` или `QTableWidget` (отображение задач).
* Корректная компоновка (без «плавающих» элементов).

#### Сигналы и слоты

* Обработка:
  * нажатий на кнопки (`clicked`),
  * изменения статуса задачи (например, двойной клик по строке).
* Пользовательские сигналы:
  * `tasks_changed` (вызывается при изменении списка задач),
  * `autosave_finished(bool success, str message)`.
* При срабатывании `tasks_changed` должен запускаться механизм сохранения (в поток).

#### Потоки

* Выделить отдельный worker для сохранения в файл:
  * Принимает текущий список задач в виде структуры данных.
  * Пишет данные в JSON в отдельном потоке.
  * По завершении посылает сигнал о результате сохранения.
* UI не должен «подвисать» при сохранении больших списков.

---

### «Монитор ресурсов системы»

**Задача:** разработать приложение, которое периодически обновляет в фоновом режиме информацию о «нагрузке» 
(CPU, RAM, диски — можно эмулировать) и отображает её в UI.

> Можно либо использовать реальные данные из `psutil`, либо полностью эмулировать значения — на ваше усмотрение

#### Функциональные требования

1. Отображение в таблице/списке текущих «ресурсов»:
   * CPU: % загрузки,
   * RAM: использовано/доступно,
   * Диск: использовано/доступно.
2. Обновление данных каждые N миллисекунд/секунд:
   * выполняется в фоновом потоке,
   * интерфейс не блокируется.
3. Возможность:
   * запускать/останавливать мониторинг,
   * изменять период обновления (через `QSpinBox`).

#### Требования к GUI и виджетам

* Виджеты:
  * `QTableWidget` или несколько `QLabel` с текущими значениями,
  * `QPushButton` (Старт, Стоп),
  * `QSpinBox`/`QSlider` (интервал опроса),
  * возможно `QChartView`/графики.
* Отображение времени последнего обновления.

#### Сигналы и слоты

* Worker:
  * `metrics_updated(dict metrics)` — словарь/структура с текущими значениями,
  * `stopped()` — мониторинг остановлен,
  * `error(str message)`.
* UI:
  * слот для обновления таблицы/лейблов при каждом `metrics_updated`,
  * слот для обработки изменения интервала (передача в worker).

#### Потоки

* Worker выполняется в отдельном потоке, который:
  * в цикле с заданным интервалом собирает/генерирует данные,
  * отправляет их в UI через сигнал.
* Корректное завершение при нажатии «Стоп» и при закрытии окна.

---

### «Импорт и просмотр CSV в отдельном потоке»

**Задача:** разработать приложение, которое загружает большой CSV-файл в таблицу, не блокируя интерфейс.

#### Функциональные требования

1. Пользователь выбирает CSV-файл.
2. Загрузка CSV:
   * выполняется в фоновом потоке построчно/пакетно;
   * отображает прогресс по количеству считанных строк;
   * позволяет отменить импорт.
3. После завершения:
   * данные отображаются в `QTableWidget` или `QTableView`;
   * пользователь может сортировать по столбцам;
   * фильтрация по подстроке (по одному выбранному столбцу).

#### Требования к GUI и виджетам

* Виджеты:
  * `QPushButton` (Выбрать файл, Импорт, Отмена),
  * `QLineEdit` (путь к файлу — только для чтения),
  * `QProgressBar` (прогресс импорта),
  * `QComboBox` (выбор столбца для фильтрации),
  * `QLineEdit` (строка фильтра),
  * `QTableWidget` или `QTableView` (данные),
  * `QLabel` (кол-во строк загружено).
* Сортировка либо средствами `QTableWidget`, либо через модель.

#### Сигналы и слоты

* Worker-сигналы:
  * `progress(int current, int total)` — прогресс;
  * `row_batch_loaded(list rows)` — партия строк (например, список списков);
  * `finished(int total_rows)` — завершено;
  * `cancelled()` — отмена;
  * `error(str message)`.
* UI-слоты:

  * добавление строк партийно в таблицу;
  * обновление прогресса;
  * включение/отключение кнопок и фильтра.

#### Потоки

* Отдельный `QThread`/`QRunnable` для чтения файла:

  * основная работа — `open`/`readline`/парсинг CSV;
  * периодически проверяет флаг отмены;
  * все операции с таблицей — через сигналы.

---

### «Таймеры и напоминания с фоновым отсчётом»

**Задача:** разработать приложение для создания нескольких таймеров/напоминаний, время которых отсчитывается 
в отдельном потоке (или нескольких).

#### Функциональные требования

1. Пользователь может создать несколько таймеров:
   * название;
   * длительность (в секундах/минутах);
   * опционально — время конкретного срабатывания.
2. Для каждого таймера:
   * отображается оставшееся время;
   * статус (идёт / на паузе / завершён).
3. По завершении таймера:
   * выводится визуальное уведомление (подсветка строки / всплывающее окно);
   * можно сбросить или перезапустить.
4. Возможность:
   * запустить/поставить на паузу отдельный таймер;
   * запустить/поставить на паузу все;
   * удалить таймер.

#### Требования к GUI и виджетам

* Виджеты:
  * поля для ввода названия (`QLineEdit`) и длительности (`QSpinBox` или `QTimeEdit`),
  * `QPushButton` (Добавить таймер, Старт/Пауза все, Сбросить все),
  * `QTableWidget` или `QTreeWidget` для списка таймеров с колонками:
    * название,
    * полная длительность,
    * оставшееся время,
    * статус,
    * индивидуальные кнопки (Старт/Пауза/Сброс/Удалить — можно через `QPushButton` в ячейках или контекстное меню).
* Отображение статусной строки (кол-во активных таймеров).

#### Сигналы и слоты

* Вариант A (один worker, несколько таймеров внутри):
  * `tick(str timer_id, int seconds_left)`;
  * `timer_finished(str timer_id)`;
  * `timer_state_changed(str timer_id, str new_state)`.
* Вариант B (по worker на таймер) — аналогичные сигналы, но от каждого.
* Слоты UI:
  * обновление соответствующей строки при каждом `tick`;
  * смена цвета/статуса при `timer_finished`;
  * запуск/паузу по нажатию кнопок в таблице.

#### Потоки

* Допустимы два подхода:
  * один поток-таймер, внутри которого управляются все таймеры;
  * отдельный поток на таймер.
* Поток:
  * не трогает UI;
  * работает в цикле с шагом 1 секунда;
  * по каждому шагу сигналы в UI;
  * учитывает флаги паузы/остановки.

---

## Возможен вариант реализации своего проекта с использованием бибилотеки PySide6, общий объемом которого не менее 400 строк  